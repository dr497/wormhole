[{"/Users/david/Desktop/wormhole/web/src/index.tsx":"1","/Users/david/Desktop/wormhole/web/src/serviceWorker.ts":"2","/Users/david/Desktop/wormhole/web/src/App/App.tsx":"3","/Users/david/Desktop/wormhole/web/src/config.ts":"4","/Users/david/Desktop/wormhole/web/src/providers/WalletContext.ts":"5","/Users/david/Desktop/wormhole/web/src/providers/ClientContext.ts":"6","/Users/david/Desktop/wormhole/web/src/providers/SlotContext.tsx":"7","/Users/david/Desktop/wormhole/web/src/providers/SolanaTokenContext.tsx":"8","/Users/david/Desktop/wormhole/web/src/providers/BridgeContext.tsx":"9","/Users/david/Desktop/wormhole/web/src/pages/TransferSolana.tsx":"10","/Users/david/Desktop/wormhole/web/src/pages/Assistant.tsx":"11","/Users/david/Desktop/wormhole/web/src/pages/Transfer.tsx":"12","/Users/david/Desktop/wormhole/web/src/utils/bridge.ts":"13","/Users/david/Desktop/wormhole/web/src/contracts/Erc20Factory.ts":"14","/Users/david/Desktop/wormhole/web/src/contracts/WrappedAssetFactory.ts":"15","/Users/david/Desktop/wormhole/web/src/contracts/WormholeFactory.ts":"16","/Users/david/Desktop/wormhole/web/src/components/SplBalances.tsx":"17","/Users/david/Desktop/wormhole/web/src/components/TransferInitiator.tsx":"18","/Users/david/Desktop/wormhole/web/src/components/TransferProposals.tsx":"19","/Users/david/Desktop/wormhole/web/src/utils/helpers.ts":"20"},{"size":507,"mtime":1612358977855,"results":"21","hashOfConfig":"22"},{"size":5295,"mtime":1612358977858,"results":"23","hashOfConfig":"22"},{"size":4344,"mtime":1612358982745,"results":"24","hashOfConfig":"22"},{"size":531,"mtime":1612358982746,"results":"25","hashOfConfig":"22"},{"size":251,"mtime":1612358977857,"results":"26","hashOfConfig":"22"},{"size":249,"mtime":1612358977857,"results":"27","hashOfConfig":"22"},{"size":635,"mtime":1612358977857,"results":"28","hashOfConfig":"22"},{"size":2986,"mtime":1612358977857,"results":"29","hashOfConfig":"22"},{"size":773,"mtime":1612358977856,"results":"30","hashOfConfig":"22"},{"size":7726,"mtime":1612358977856,"results":"31","hashOfConfig":"22"},{"size":14850,"mtime":1612363758976,"results":"32","hashOfConfig":"22"},{"size":13190,"mtime":1612358977856,"results":"33","hashOfConfig":"22"},{"size":18775,"mtime":1612358977859,"results":"34","hashOfConfig":"22"},{"size":16213,"mtime":1611753992140,"results":"35","hashOfConfig":"22"},{"size":21569,"mtime":1611753992141,"results":"36","hashOfConfig":"22"},{"size":38230,"mtime":1611753992140,"results":"37","hashOfConfig":"22"},{"size":1454,"mtime":1612358977853,"results":"38","hashOfConfig":"22"},{"size":13277,"mtime":1612358982745,"results":"39","hashOfConfig":"22"},{"size":6990,"mtime":1612358977854,"results":"40","hashOfConfig":"22"},{"size":600,"mtime":1612358977859,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1ebpe07",{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"46"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"46"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"67","messages":"68","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"46"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82","usedDeprecatedRules":"46"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85","usedDeprecatedRules":"46"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},"/Users/david/Desktop/wormhole/web/src/index.tsx",[],"/Users/david/Desktop/wormhole/web/src/serviceWorker.ts",[],["88","89"],"/Users/david/Desktop/wormhole/web/src/App/App.tsx",["90","91"],"/Users/david/Desktop/wormhole/web/src/config.ts",[],"/Users/david/Desktop/wormhole/web/src/providers/WalletContext.ts",[],"/Users/david/Desktop/wormhole/web/src/providers/ClientContext.ts",[],"/Users/david/Desktop/wormhole/web/src/providers/SlotContext.tsx",[],"/Users/david/Desktop/wormhole/web/src/providers/SolanaTokenContext.tsx",["92"],"import React, {createContext, FunctionComponent, useContext, useEffect, useState} from \"react\"\nimport ClientContext from \"../providers/ClientContext\";\nimport {AccountInfo, ParsedAccountData, PublicKey, RpcResponseAndContext} from \"@solana/web3.js\";\nimport {BigNumber} from \"ethers/utils\";\nimport {SlotContext} from \"./SlotContext\";\nimport {TOKEN_PROGRAM} from \"../config\";\nimport {BridgeContext} from \"./BridgeContext\";\nimport {message} from \"antd\";\nimport {AssetMeta} from \"../utils/bridge\";\nimport {Buffer} from \"buffer\";\nimport WalletContext from \"./WalletContext\";\n\nexport interface BalanceInfo {\n    mint: string,\n    account: PublicKey,\n    balance: BigNumber,\n    decimals: number,\n    assetMeta: AssetMeta\n}\n\nexport interface TokenInfo {\n    balances: Array<BalanceInfo>\n    loading: boolean\n}\n\nexport const SolanaTokenContext = createContext<TokenInfo>({\n    balances: [],\n    loading: false\n})\n\nexport const SolanaTokenProvider: FunctionComponent = ({children}) => {\n    let wallet = useContext(WalletContext);\n    let c = useContext(ClientContext);\n    let b = useContext(BridgeContext);\n    let slot = useContext(SlotContext);\n\n    let [loading, setLoading] = useState(true)\n    let [balances, setBalances] = useState<Array<BalanceInfo>>([]);\n    let [lastUpdate, setLastUpdate] = useState(0);\n\n    useEffect(() => {\n            if (slot - lastUpdate <= 16) {\n                return\n            }\n            setLastUpdate(slot);\n\n            // @ts-ignore\n            setLoading(true)\n            let getAccounts = async () => {\n                let res: RpcResponseAndContext<Array<{ pubkey: PublicKey; account: AccountInfo<ParsedAccountData> }>> = await c.getParsedTokenAccountsByOwner(wallet.publicKey, {programId: TOKEN_PROGRAM}, \"single\")\n                let meta: AssetMeta[] = [];\n                for (let acc of res.value) {\n                    let am = await b?.fetchAssetMeta(new PublicKey(acc.account.data.parsed.info.mint))\n                    if (!am) {\n                        throw new Error(\"could not derive asset meta\")\n                    }\n                    am.decimals = acc.account.data.parsed.info.tokenAmount.decimals;\n                    meta.push(am)\n                }\n                let balances: Array<BalanceInfo> = await res.value.map((v, i) => {\n                    return {\n                        mint: v.account.data.parsed.info.mint,\n                        account: v.pubkey,\n                        balance: new BigNumber(v.account.data.parsed.info.tokenAmount.amount),\n                        decimals: v.account.data.parsed.info.tokenAmount.decimals,\n                        assetMeta: meta[i],\n                    }\n                })\n                setBalances(balances)\n                setLoading(false)\n\n            }\n            getAccounts();\n        },\n        [slot]\n    )\n\n    return (\n        <SolanaTokenContext.Provider value={{balances, loading}}>\n            {children}\n        </SolanaTokenContext.Provider>\n    )\n}\n","/Users/david/Desktop/wormhole/web/src/providers/BridgeContext.tsx",[],"/Users/david/Desktop/wormhole/web/src/pages/TransferSolana.tsx",["93"],"import React, {useContext, useEffect, useState} from 'react';\nimport ClientContext from \"../providers/ClientContext\";\nimport * as solanaWeb3 from '@solana/web3.js';\nimport {PublicKey, Transaction} from '@solana/web3.js';\nimport * as spl from '@solana/spl-token';\nimport {Button, Col, Form, Input, InputNumber, message, Row, Select} from \"antd\";\nimport {BigNumber} from \"ethers/utils\";\nimport SplBalances from \"../components/SplBalances\";\nimport {SlotContext} from \"../providers/SlotContext\";\nimport {SolanaTokenContext} from \"../providers/SolanaTokenContext\";\nimport {CHAIN_ID_SOLANA} from \"../utils/bridge\";\nimport {BridgeContext} from \"../providers/BridgeContext\";\nimport BN from 'bn.js';\nimport {TOKEN_PROGRAM} from \"../config\";\nimport WalletContext from \"../providers/WalletContext\";\n\nfunction TransferSolana() {\n    let c = useContext<solanaWeb3.Connection>(ClientContext);\n    let slot = useContext(SlotContext);\n    let b = useContext(SolanaTokenContext);\n    let bridge = useContext(BridgeContext);\n    let wallet = useContext(WalletContext);\n\n    let [coinInfo, setCoinInfo] = useState({\n        balance: new BigNumber(0),\n        decimals: 0,\n        isWrapped: false,\n        chainID: 0,\n        wrappedAddress: new Buffer([]),\n        mint: \"\"\n    });\n    let [amount, setAmount] = useState(new BigNumber(0));\n    let [address, setAddress] = useState(\"\");\n    let [addressValid, setAddressValid] = useState(false)\n\n    useEffect(() => {\n        async function getCoinInfo() {\n            let acc = b.balances.find(value => value.account.toString() == address)\n            if (!acc) {\n                setAmount(new BigNumber(0));\n                setAddressValid(false)\n                return\n            }\n\n            setCoinInfo({\n                balance: acc.balance,\n                decimals: acc.decimals,\n                isWrapped: acc.assetMeta.chain != CHAIN_ID_SOLANA,\n                chainID: acc.assetMeta.chain,\n                wrappedAddress: acc.assetMeta.address,\n                mint: acc.mint\n            })\n            setAddressValid(true)\n        }\n\n        getCoinInfo()\n    }, [address])\n\n\n    return (\n        <>\n            <Row gutter={12}>\n                <Col span={12}>\n                    <p>Transfer from Solana:</p>\n                    <Form onFinish={(values) => {\n                        let recipient = new Buffer(values[\"recipient\"].slice(2), \"hex\");\n\n                        let transferAmount = new BN(values[\"amount\"]).mul(new BN(10).pow(new BN(coinInfo.decimals)));\n                        let fromAccount = new PublicKey(values[\"address\"])\n\n                        let send = async () => {\n                            message.loading({content: \"Transferring tokens...\", key: \"transfer\"}, 1000)\n\n                            let {ix: lock_ix} = await bridge.createLockAssetInstruction(wallet.publicKey, fromAccount, new PublicKey(coinInfo.mint), transferAmount, values[\"target_chain\"], recipient,\n                                {\n                                    chain: coinInfo.chainID,\n                                    address: coinInfo.wrappedAddress,\n                                    decimals: Math.min(coinInfo.decimals, 9)\n                                }, Math.random() * 100000);\n                            let ix = spl.Token.createApproveInstruction(TOKEN_PROGRAM, fromAccount, await bridge.getConfigKey(), wallet.publicKey, [], transferAmount.toNumber())\n                            let bridge_account = await bridge.getConfigKey();\n                            let fee_ix = solanaWeb3.SystemProgram.transfer({\n                                fromPubkey: wallet.publicKey,\n                                toPubkey: bridge_account,\n                                lamports: await bridge.getTransferFee()\n                            });\n\n                            let recentHash = await c.getRecentBlockhash();\n                            let tx = new Transaction();\n                            tx.recentBlockhash = recentHash.blockhash\n                            tx.add(ix)\n                            tx.add(fee_ix)\n                            tx.add(lock_ix)\n                            tx.feePayer = wallet.publicKey;\n                            let signed = await wallet.signTransaction(tx)\n                            try {\n                                await c.sendRawTransaction(signed.serialize())\n                                message.success({content: \"Transfer succeeded\", key: \"transfer\"})\n                            } catch (e) {\n                                message.error({content: \"Transfer failed\", key: \"transfer\"})\n                            }\n                        }\n                        send()\n                    }} layout={\"vertical\"}>\n                        <Form.Item name=\"address\" validateStatus={addressValid ? \"success\" : \"error\"}\n                                   label={\"Token Account:\"}>\n                            <Input\n                                addonAfter={`Balance: ${coinInfo.balance.div(new BigNumber(Math.pow(10, coinInfo.decimals)))}`}\n                                name=\"address\"\n                                placeholder={\"Token account Pubkey\"}\n                                onBlur={(v) => {\n                                    setAddress(v.target.value)\n                                }}/>\n                        </Form.Item>\n                        <Form.Item name=\"amount\" rules={[{\n                            required: true, validator: (rule, value, callback) => {\n                                let big = new BigNumber(value).mul(new BigNumber(10).pow(coinInfo.decimals));\n                                callback(big.lte(coinInfo.balance) ? undefined : \"Amount exceeds balance\")\n                            }\n                        }]} label={\"Amount:\"}>\n                            <InputNumber name={\"amount\"} placeholder={\"Amount\"} type={\"number\"} onChange={value => {\n                                // @ts-ignore\n                                setAmount(value || 0)\n                            }}/>\n                        </Form.Item>\n                        <Form.Item name=\"target_chain\"\n                                   rules={[{required: true, message: \"Please choose a target chain\"}]}\n                                   label={\"Target Chain:\"}>\n                            <Select placeholder=\"Target Chain\">\n                                <Select.Option value={2}>\n                                    Ethereum\n                                </Select.Option>\n                            </Select>\n                        </Form.Item>\n                        <Form.Item name=\"recipient\" rules={[{\n                            required: true,\n                            validator: (rule, value, callback) => {\n                                if (value.length !== 42 || value.indexOf(\"0x\") != 0) {\n                                    callback(\"Invalid address\")\n                                } else {\n                                    callback()\n                                }\n                            }\n                        }]} label={\"Recipient:\"}>\n                            <Input name=\"recipient\" placeholder={\"Address of the recipient\"}/>\n                        </Form.Item>\n                        <Form.Item>\n                            <Button type=\"primary\" htmlType=\"submit\">\n                                Transfer\n                            </Button>\n                        </Form.Item>\n                    </Form>\n                </Col>\n            </Row>\n            <Row>\n                <Col>\n                    <SplBalances/>\n                </Col>\n            </Row>\n        </>\n    );\n}\n\nexport default TransferSolana;\n","/Users/david/Desktop/wormhole/web/src/pages/Assistant.tsx",["94","95","96","97","98","99","100","101","102","103","104","105","106","107","108"],"/Users/david/Desktop/wormhole/web/src/pages/Transfer.tsx",["109"],"import React, {useContext, useEffect, useState} from 'react';\nimport ClientContext from \"../providers/ClientContext\";\nimport * as solanaWeb3 from '@solana/web3.js';\nimport {Account, Connection, PublicKey, Transaction} from '@solana/web3.js';\nimport {Button, Card, Col, Divider, Form, Input, InputNumber, List, message, Row, Select} from \"antd\";\nimport {ethers} from \"ethers\";\nimport {Erc20Factory} from \"../contracts/Erc20Factory\";\nimport {Arrayish, BigNumber, BigNumberish} from \"ethers/utils\";\nimport {WormholeFactory} from \"../contracts/WormholeFactory\";\nimport {WrappedAssetFactory} from \"../contracts/WrappedAssetFactory\";\nimport {BRIDGE_ADDRESS} from \"../config\";\nimport {SolanaTokenContext} from \"../providers/SolanaTokenContext\";\nimport {BridgeContext} from \"../providers/BridgeContext\";\nimport {AssetMeta, SolanaBridge} from \"../utils/bridge\";\nimport {FormInstance} from \"antd/lib/form\";\nimport SplBalances from \"../components/SplBalances\";\nimport TransferProposals from \"../components/TransferProposals\";\nimport WalletContext from \"../providers/WalletContext\";\nimport Wallet from \"@project-serum/sol-wallet-adapter\";\n\n// @ts-ignore\nif (window.ethereum === undefined) {\n    alert(\"Please install the MetaMask extension before using this experimental demo web UI\");\n}\n\n// @ts-ignore\nwindow.ethereum.enable();\n// @ts-ignore\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\nconst signer = provider.getSigner();\n\nasync function lockAssets(asset: string,\n                          amount: BigNumberish,\n                          recipient: Arrayish,\n                          target_chain: BigNumberish) {\n    let wh = WormholeFactory.connect(BRIDGE_ADDRESS, signer);\n    try {\n        message.loading({content: \"Signing transaction...\", key: \"eth_tx\", duration: 1000},)\n        let res = await wh.lockAssets(asset, amount, recipient, target_chain, 10, false)\n        message.loading({content: \"Waiting for transaction to be mined...\", key: \"eth_tx\", duration: 1000})\n        await res.wait(1);\n        message.success({content: \"Transfer on ETH succeeded!\", key: \"eth_tx\"})\n    } catch (e) {\n        console.log(e)\n        message.error({content: \"Transfer failed\", key: \"eth_tx\"})\n    }\n}\n\nasync function approveAssets(asset: string,\n                             amount: BigNumberish) {\n    let e = Erc20Factory.connect(asset, signer);\n    try {\n        message.loading({content: \"Signing transaction...\", key: \"eth_tx\", duration: 1000})\n        let res = await e.approve(BRIDGE_ADDRESS, amount)\n        message.loading({content: \"Waiting for transaction to be mined...\", key: \"eth_tx\", duration: 1000})\n        await res.wait(1);\n        message.success({content: \"Approval on ETH succeeded!\", key: \"eth_tx\"})\n    } catch (e) {\n        message.error({content: \"Approval failed\", key: \"eth_tx\"})\n    }\n}\n\nasync function createWrapped(c: Connection, b: SolanaBridge, wallet: Wallet, meta: AssetMeta, mint: PublicKey) {\n    try {\n        let tx = new Transaction();\n\n        // @ts-ignore\n        let [ix_account, newSigner] = await b.createWrappedAssetAndAccountInstructions(key.publicKey, mint, meta);\n        let recentHash = await c.getRecentBlockhash();\n        tx.recentBlockhash = recentHash.blockhash\n        tx.add(...ix_account)\n        tx.sign(newSigner)\n        tx.feePayer = wallet.publicKey;\n        let signed = await wallet.signTransaction(tx);\n        message.loading({content: \"Waiting for transaction to be confirmed...\", key: \"tx\", duration: 1000})\n        await c.sendRawTransaction(signed.serialize())\n        message.success({content: \"Creation succeeded!\", key: \"tx\"})\n    } catch (e) {\n        console.log(e)\n        message.error({content: \"Creation failed\", key: \"tx\"})\n    }\n}\n\nfunction Transfer() {\n    let c = useContext<solanaWeb3.Connection>(ClientContext);\n    let tokenAccounts = useContext(SolanaTokenContext);\n    let bridge = useContext(BridgeContext);\n    let wallet = useContext(WalletContext);\n\n    let [coinInfo, setCoinInfo] = useState({\n        balance: new BigNumber(0),\n        decimals: 0,\n        allowance: new BigNumber(0),\n        isWrapped: false,\n        chainID: 0,\n        assetAddress: new Buffer(\"\")\n    });\n    let [amount, setAmount] = useState(new BigNumber(0));\n    let [amountValid, setAmountValid] = useState(false);\n\n    let [address, setAddress] = useState(\"\");\n    let [addressValid, setAddressValid] = useState(false)\n\n    let [solanaAccount, setSolanaAccount] = useState({\n        valid: false,\n        message: \"\"\n    })\n    let [wrappedMint, setWrappedMint] = useState(\"\")\n    let [recipient, setRecipient] = useState(\"\")\n\n    let [transacting, setTransacting] = useState(false);\n\n    let formRef = React.createRef<FormInstance>();\n\n    useEffect(() => {\n        let fetchBalance = async (token: string) => {\n            try {\n                let e = WrappedAssetFactory.connect(token, provider);\n                let addr = await signer.getAddress();\n                let balance = await e.balanceOf(addr);\n                let decimals = await e.decimals();\n                let allowance = await e.allowance(addr, BRIDGE_ADDRESS);\n\n                let info = {\n                    balance: balance.div(new BigNumber(10).pow(decimals)),\n                    allowance: allowance.div(new BigNumber(10).pow(decimals)),\n                    decimals: decimals,\n                    isWrapped: false,\n                    chainID: 2,\n                    assetAddress: new Buffer(token.slice(2), \"hex\")\n                }\n\n                let b = WormholeFactory.connect(BRIDGE_ADDRESS, provider);\n\n                let isWrapped = await b.isWrappedAsset(token)\n                if (isWrapped) {\n                    info.chainID = await e.assetChain()\n                    info.assetAddress = new Buffer((await e.assetAddress()).slice(2), \"hex\")\n                    info.isWrapped = true\n                }\n                setCoinInfo(info)\n                setAddressValid(true)\n            } catch (e) {\n                setAddressValid(false)\n            }\n        }\n        fetchBalance(address)\n    }, [address, transacting])\n\n    useEffect(() => {\n        if (!addressValid) {\n            setWrappedMint(\"\")\n            setSolanaAccount({\n                valid: false,\n                message: \"\"\n            })\n            return\n        }\n\n        let getWrappedInfo = async () => {\n            let wrappedMint = await bridge.getWrappedAssetMint({\n                chain: coinInfo.chainID,\n                address: coinInfo.assetAddress,\n                decimals: Math.min(coinInfo.decimals, 9)\n            });\n            setWrappedMint(wrappedMint.toString())\n\n            for (let account of tokenAccounts.balances) {\n                if (account.account.toString() == recipient) {\n                    setSolanaAccount({\n                        valid: true,\n                        message: \"\"\n                    })\n                    return;\n                }\n            }\n            setSolanaAccount({\n                valid: false,\n                message: \"Not a valid wrapped token account\"\n            })\n        }\n        getWrappedInfo();\n    }, [address, addressValid, tokenAccounts, bridge])\n\n    useEffect(() => {\n        setAmountValid(amount.lte(coinInfo.balance))\n    }, [amount, coinInfo])\n\n    return (\n        <>\n            <Row gutter={12}>\n                <Col span={12}>\n                    <Form onFinish={(values) => {\n                        let recipient = new solanaWeb3.PublicKey(values[\"recipient\"]).toBuffer()\n                        let transferAmount = new BigNumber(values[\"amount\"]).mul(new BigNumber(10).pow(coinInfo.decimals));\n                        setTransacting(true)\n                        if (coinInfo.allowance.gte(amount) || coinInfo.isWrapped) {\n                            lockAssets(values[\"address\"], transferAmount, recipient, values[\"target_chain\"]).finally(() => {\n                                setTransacting(false)\n                            })\n                        } else {\n                            approveAssets(values[\"address\"], transferAmount).finally(() => {\n                                setTransacting(false)\n                            })\n                        }\n                    }} style={{width: \"100%\"}} ref={formRef} layout={\"vertical\"}>\n                        <Form.Item name=\"address\" validateStatus={addressValid ? \"success\" : \"error\"} label={\"Token:\"}>\n                            <Input addonAfter={`Balance: ${coinInfo.balance}`} name=\"address\"\n                                   placeholder={\"ERC20 address\"}\n                                   onBlur={(v) => {\n                                       setAddress(v.target.value)\n                                   }}/>\n                        </Form.Item>\n                        <Form.Item name=\"amount\" validateStatus={amountValid ? \"success\" : \"error\"} label={\"Amount:\"}>\n                            <InputNumber name={\"amount\"} placeholder={\"Amount\"} type={\"number\"} min={0}\n                                         onChange={value => {\n                                             // @ts-ignore\n                                             setAmount(new BigNumber(value) || 0)\n                                         }}/>\n                        </Form.Item>\n                        <Form.Item name=\"target_chain\"\n                                   label={\"Target Chain:\"}>\n                            <Select placeholder=\"Target Chain\">\n                                <Select.Option value={1}>\n                                    Solana\n                                </Select.Option>\n                            </Select>\n                        </Form.Item>\n                        <Form.Item name=\"recipient\" validateStatus={solanaAccount.valid ? \"success\" : \"error\"}\n                                   help={recipient === \"\" ? undefined : solanaAccount.message} label={\"Recipient\"}>\n                            <Input name=\"recipient\" placeholder={\"Address of the recipient\"}\n                                   onFocus={(v) => {\n                                       setRecipient(v.target.value)\n                                   }}/>\n                        </Form.Item>\n                        <Form.Item>\n                            <Button type=\"primary\" htmlType=\"submit\" style={{marginLeft: \"auto\"}}\n                                    disabled={transacting}>\n                                {coinInfo.allowance.gte(amount) || coinInfo.isWrapped ? \"Transfer\" : \"Approve\"}\n                            </Button>\n                        </Form.Item>\n                    </Form>\n                </Col>\n                <Col span={12}>\n                    <Card>\n                        <Row justify={\"space-between\"} align={\"middle\"}>\n                            <Col>Token Accounts on Solana:</Col>\n                            <Col><Button size={\"small\"}\n                                         disabled={wrappedMint === \"\"}\n                                         onClick={() => {\n                                             createWrapped(c, bridge, wallet, {\n                                                 chain: coinInfo.chainID,\n                                                 address: coinInfo.assetAddress,\n                                                 decimals: Math.min(coinInfo.decimals, 9)\n                                             }, new PublicKey(wrappedMint))\n                                         }}>Create new</Button></Col>\n                        </Row>\n                        <Divider/>\n                        <Row>\n                            <Col span={24}>\n                                <List>\n                                    {\n                                        tokenAccounts.balances\n                                            .filter(value => value.mint == wrappedMint)\n                                            .map(v => (\n                                                <List.Item\n                                                    actions={[(<Button size={\"small\"} type={\"dashed\"} onClick={() => {\n                                                        setRecipient(v.account.toString())\n                                                        formRef.current?.setFieldsValue({\n                                                            \"recipient\": v.account.toString()\n                                                        })\n                                                    }}>use</Button>)]}>\n                                                    {v.account.toString()}\n                                                </List.Item>\n                                            ))\n                                    }\n                                </List>\n                            </Col>\n                        </Row>\n                    </Card>\n                </Col>\n            </Row>\n            <Row>\n                <Col>\n                    <SplBalances/>\n                </Col>\n            </Row>\n            <Row>\n                <Col>\n                    <TransferProposals/>\n                </Col>\n            </Row>\n        </>\n    );\n}\n\nexport default Transfer;\n","/Users/david/Desktop/wormhole/web/src/utils/bridge.ts",[],"/Users/david/Desktop/wormhole/web/src/contracts/Erc20Factory.ts",[],"/Users/david/Desktop/wormhole/web/src/contracts/WrappedAssetFactory.ts",[],"/Users/david/Desktop/wormhole/web/src/contracts/WormholeFactory.ts",[],"/Users/david/Desktop/wormhole/web/src/components/SplBalances.tsx",[],"/Users/david/Desktop/wormhole/web/src/components/TransferInitiator.tsx",["110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128"],"import React, {useContext, useEffect, useState} from \"react\";\nimport {Button, Empty, Form, Input, message, Modal, Select} from \"antd\";\nimport solanaWeb3, {Account, Connection, PublicKey, Transaction} from \"@solana/web3.js\";\nimport ClientContext from \"../providers/ClientContext\";\nimport {SlotContext} from \"../providers/SlotContext\";\nimport {SolanaTokenContext} from \"../providers/SolanaTokenContext\";\nimport {BridgeContext} from \"../providers/BridgeContext\";\nimport {WrappedAssetFactory} from \"../contracts/WrappedAssetFactory\";\nimport {WalletOutlined} from '@ant-design/icons';\nimport {BRIDGE_ADDRESS} from \"../config\";\nimport {WormholeFactory} from \"../contracts/WormholeFactory\";\nimport {ethers} from \"ethers\";\nimport debounce from \"lodash.debounce\"\nimport BN from \"bignumber.js\";\nimport {BigNumber} from \"ethers/utils\";\nimport {AssetMeta, SolanaBridge} from \"../utils/bridge\";\nimport {ChainID} from \"../pages/Assistant\";\nimport WalletContext from \"../providers/WalletContext\";\nimport Wallet from \"@project-serum/sol-wallet-adapter\";\n\nconst {confirm} = Modal;\n\nconst {Option} = Select;\n\ninterface TransferInitiatorParams {\n    onFromNetworkChanged?: (v: ChainID) => void\n    dataChanged?: (d: TransferInitiatorData) => void\n}\n\nexport interface CoinInfo {\n    address: string,\n    name: string,\n    balance: BigNumber,\n    decimals: number,\n    allowance: BigNumber,\n    isWrapped: boolean,\n    chainID: number,\n    assetAddress: Buffer,\n    mint: string,\n}\n\nexport interface TransferInitiatorData {\n    fromNetwork: ChainID,\n    fromCoinInfo: CoinInfo\n    toNetwork: ChainID,\n    toAddress: Buffer,\n    amount: BigNumber,\n}\n\n// @ts-ignore\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\nconst signer = provider.getSigner();\n\nexport const defaultCoinInfo = {\n    address: \"\",\n    name: \"\",\n    balance: new BigNumber(0),\n    decimals: 0,\n    allowance: new BigNumber(0),\n    isWrapped: false,\n    chainID: 0,\n    assetAddress: new Buffer(0),\n    mint: \"\"\n}\n\nlet debounceUpdater = debounce((e) => e(), 500)\n\nasync function createWrapped(c: Connection, b: SolanaBridge, wallet: Wallet, meta: AssetMeta, mint: PublicKey) {\n    try {\n        let tx = new Transaction();\n\n        // @ts-ignore\n        let [ix_account, newSigner] = await b.createWrappedAssetAndAccountInstructions(key.publicKey, mint, meta);\n        let recentHash = await c.getRecentBlockhash();\n        tx.recentBlockhash = recentHash.blockhash\n        tx.add(...ix_account)\n        tx.feePayer = wallet.publicKey;\n        let signed = await wallet.signTransaction(tx);\n        message.loading({content: \"Waiting for transaction to be confirmed...\", key: \"tx\", duration: 1000})\n        await c.sendRawTransaction(signed.serialize(), {preflightCommitment: \"single\"})\n        message.success({content: \"Creation succeeded!\", key: \"tx\"})\n    } catch (e) {\n        console.log(e)\n        message.error({content: \"Creation failed\", key: \"tx\"})\n    }\n}\n\nexport default function TransferInitiator(params: TransferInitiatorParams) {\n    let c = useContext<solanaWeb3.Connection>(ClientContext);\n    let slot = useContext(SlotContext);\n    let b = useContext(SolanaTokenContext);\n    let bridge = useContext(BridgeContext);\n    let wallet = useContext(WalletContext);\n\n    let [fromNetwork, setFromNetwork] = useState(ChainID.ETH);\n    let [toNetwork, setToNetwork] = useState(ChainID.SOLANA);\n    let [fromAddress, setFromAddress] = useState(\"\");\n    let [fromAddressValid, setFromAddressValid] = useState(false)\n    let [coinInfo, setCoinInfo] = useState<CoinInfo>(defaultCoinInfo);\n    let [toAddress, setToAddress] = useState(\"\");\n    let [toAddressValid, setToAddressValid] = useState(false)\n    let [amount, setAmount] = useState(new BigNumber(0));\n    let [amountValid, setAmountValid] = useState(true);\n\n    let [wrappedMint, setWrappedMint] = useState(\"\")\n\n    const updateBalance = async () => {\n        if (fromNetwork == ChainID.SOLANA) {\n            let acc = b.balances.find(value => value.account.toString() == fromAddress)\n            if (!acc) {\n                setFromAddressValid(false);\n                setCoinInfo(defaultCoinInfo);\n                return\n            }\n\n            setCoinInfo({\n                address: fromAddress,\n                name: \"\",\n                balance: acc.balance,\n                allowance: new BigNumber(0),\n                decimals: acc.assetMeta.decimals,\n                isWrapped: acc.assetMeta.chain != ChainID.SOLANA,\n                chainID: acc.assetMeta.chain,\n                assetAddress: acc.assetMeta.address,\n\n                // Solana specific\n                mint: acc.mint,\n            })\n            setFromAddressValid(true);\n        } else {\n            try {\n                let e = WrappedAssetFactory.connect(fromAddress, provider);\n                let addr = await signer.getAddress();\n                let balance = await e.balanceOf(addr);\n                let decimals = await e.decimals();\n                let symbol = await e.symbol();\n                let allowance = await e.allowance(addr, BRIDGE_ADDRESS);\n\n                let info = {\n                    address: fromAddress,\n                    name: symbol,\n                    balance: balance,\n                    allowance: allowance,\n                    decimals: decimals,\n                    isWrapped: false,\n                    chainID: 2,\n                    assetAddress: new Buffer(fromAddress.slice(2), \"hex\"),\n                    mint: \"\",\n                }\n\n                let b = WormholeFactory.connect(BRIDGE_ADDRESS, provider);\n\n                let isWrapped = await b.isWrappedAsset(fromAddress)\n                if (isWrapped) {\n                    info.chainID = await e.assetChain()\n                    info.assetAddress = new Buffer((await e.assetAddress()).slice(2), \"hex\")\n                    info.isWrapped = true\n                }\n\n                let wrappedMint = await bridge.getWrappedAssetMint({\n                    chain: info.chainID,\n                    address: info.assetAddress,\n                    decimals: Math.min(decimals, 9),\n                });\n                console.log(decimals)\n\n                setWrappedMint(wrappedMint.toString())\n                setCoinInfo(info)\n                setFromAddressValid(true)\n            } catch (e) {\n                setCoinInfo(defaultCoinInfo);\n                setFromAddressValid(false)\n            }\n        }\n    }\n    useEffect(() => {\n        debounceUpdater(updateBalance)\n    }, [fromNetwork, fromAddress])\n\n    useEffect(() => {\n        if (toNetwork == ChainID.ETH) {\n            setToAddressValid(toAddress.length == 42 && toAddress.match(/0[xX][0-9a-fA-F]+/) != null)\n        } else {\n            setToAddressValid(toAddress != \"\")\n        }\n    }, [toNetwork, toAddress])\n\n    useEffect(() => {\n        setAmountValid(amount.lte(coinInfo.balance) && amount.gt(0))\n    }, [amount])\n\n    useEffect(() => {\n        if (params.dataChanged) {\n            params.dataChanged({\n                fromCoinInfo: coinInfo,\n                fromNetwork,\n                toNetwork,\n                toAddress: toAddressValid ? (toNetwork == ChainID.ETH ? new Buffer(toAddress.slice(2), \"hex\") : new PublicKey(toAddress).toBuffer()) : new Buffer(0),\n                amount: amount,\n            });\n        }\n    }, [fromNetwork, fromAddressValid, coinInfo, toNetwork, toAddress, toAddressValid, amount])\n\n    return (\n        <>\n            <Form layout={\"vertical\"}>\n                <Form.Item label=\"From\" name=\"layout\" validateStatus={fromAddressValid ? \"success\" : \"error\"}>\n                    <Input.Group compact={true}>\n                        <Select style={{width: '30%'}} defaultValue={ChainID.ETH} className=\"select-before\"\n                                value={fromNetwork}\n                                onChange={(v: ChainID) => {\n                                    setFromNetwork(v);\n                                    setFromAddress(\"\");\n                                    if (v === toNetwork) {\n                                        setToNetwork(v == ChainID.ETH ? ChainID.SOLANA : ChainID.ETH);\n                                    }\n                                    if (params.onFromNetworkChanged) params.onFromNetworkChanged(v);\n                                }}>\n                            <Option value={ChainID.ETH}>Ethereum</Option>\n                            <Option value={ChainID.SOLANA}>Solana</Option>\n                        </Select>\n                        {fromNetwork == ChainID.ETH &&\n\n                        <Input style={{width: '70%'}} placeholder=\"ERC20 address\"\n                               onChange={(e) => setFromAddress(e.target.value)}\n                               suffix={coinInfo.name}/>}\n                        {fromNetwork == ChainID.SOLANA &&\n                        <>\n                            <Select style={{width: '70%'}} placeholder=\"Pick a token account\"\n                                    onChange={(e) => {\n                                        setFromAddress(e.toString())\n                                    }}>\n                                {b.balances.map((v) => <Option\n                                    value={v.account.toString()}>{v.account.toString()}</Option>)}\n                            </Select>\n                        </>\n                        }\n                    </Input.Group>\n                </Form.Item>\n                <Form.Item label=\"Amount\" name=\"layout\"\n                           validateStatus={amountValid ? \"success\" : \"error\"}>\n                    <Input type={\"number\"} placeholder={\"Amount\"}\n                           addonAfter={`Balance: ${coinInfo.balance.div(new BigNumber(10).pow(coinInfo.decimals))}`}\n                           onChange={(v) => {\n                               if (v.target.value === \"\") {\n                                   setAmount(new BigNumber(0));\n                                   return\n                               }\n                               setAmount(new BigNumber(new BN(v.target.value).multipliedBy(new BN(Math.pow(10, coinInfo.decimals))).toFixed(0)))\n                           }}/>\n                </Form.Item>\n                <Form.Item label=\"Recipient\" name=\"layout\" validateStatus={toAddressValid ? \"success\" : \"error\"}>\n                    <Input.Group compact={true}>\n                        <Select style={{width: '30%'}} defaultValue={ChainID.SOLANA} className=\"select-before\"\n                                value={toNetwork}\n                                onChange={(v: ChainID) => {\n                                    setToNetwork(v)\n                                    if (v === fromNetwork) {\n                                        setFromNetwork(v == ChainID.ETH ? ChainID.SOLANA : ChainID.ETH);\n                                    }\n                                    setToAddress(\"\");\n                                }}>\n                            <Option value={ChainID.ETH}>Ethereum</Option>\n                            <Option value={ChainID.SOLANA}>Solana</Option>\n                        </Select>\n                        {toNetwork == ChainID.ETH &&\n\n                        <Input style={{width: '70%'}} placeholder=\"Account address\"\n                               onChange={(e) => setToAddress(e.target.value)}/>}\n                        {toNetwork == ChainID.SOLANA &&\n                        <>\n                            <Select style={{width: '60%'}} onChange={(e) => setToAddress(e.toString())}\n                                    placeholder=\"Pick a token account or create a new one\"\n                                    notFoundContent={<Empty description=\"No accounts. Create a new one.\"/>}>\n                                {b.balances.filter((v) => v.mint == wrappedMint).map((v) =>\n                                    <Option\n                                        value={v.account.toString()}>{v.account.toString()}</Option>)}\n                            </Select>\n                            <Button style={{width: '10%'}} disabled={!fromAddressValid} onClick={() => {\n                                confirm({\n                                    title: 'Do you want to create a new token account?',\n                                    icon: <WalletOutlined/>,\n                                    content: (<>This will create a new token account for the\n                                        token: <code>{wrappedMint}</code></>),\n                                    onOk() {\n                                        createWrapped(c, bridge, wallet, {\n                                            chain: coinInfo.chainID,\n                                            address: coinInfo.assetAddress,\n                                            decimals: Math.min(coinInfo.decimals, 9)\n                                        }, new PublicKey(wrappedMint))\n                                    },\n                                    onCancel() {\n                                    },\n                                })\n                            }}>+</Button>\n                        </>\n                        }\n                    </Input.Group>\n                </Form.Item>\n            </Form>\n        </>\n    );\n}\n","/Users/david/Desktop/wormhole/web/src/components/TransferProposals.tsx",["129","130"],"import React, {useContext, useEffect, useState} from \"react\"\nimport {SolanaTokenContext} from \"../providers/SolanaTokenContext\";\nimport {Button, message, Table} from \"antd\";\nimport {Lockup} from \"../utils/bridge\";\nimport {BridgeContext} from \"../providers/BridgeContext\";\nimport {SlotContext} from \"../providers/SlotContext\";\nimport {ethers} from \"ethers\";\nimport {WormholeFactory} from \"../contracts/WormholeFactory\";\nimport {BRIDGE_ADDRESS} from \"../config\";\nimport {keccak256} from \"ethers/utils\";\nimport BN from 'bn.js';\nimport {PublicKey, Transaction} from \"@solana/web3.js\";\nimport ClientContext from \"../providers/ClientContext\";\nimport WalletContext from \"../providers/WalletContext\";\n\n// @ts-ignore\nif (window.ethereum === undefined) {\n    alert(\"Please install the MetaMask extension before using this experimental demo web UI\");\n}\n\n// @ts-ignore\nwindow.ethereum.enable();\n// @ts-ignore\nconst provider = new ethers.providers.Web3Provider(window.ethereum);\nconst signer = provider.getSigner();\n\ninterface LockupWithStatus extends Lockup {\n    status: LockupStatus,\n}\n\nenum LockupStatus {\n    AWAITING_VAA,\n    UNCLAIMED_VAA,\n    COMPLETED\n}\n\nfunction TransferProposals() {\n    let s = useContext(SlotContext);\n    let t = useContext(SolanaTokenContext);\n    let tokens = useContext(SolanaTokenContext);\n    let b = useContext(BridgeContext);\n    let wallet = useContext(WalletContext);\n    let c = useContext(ClientContext);\n\n    let [lockups, setLockups] = useState<LockupWithStatus[]>([])\n    let [lastUpdate, setLastUpdate] = useState(0);\n\n    useEffect(() => {\n        if (s - lastUpdate <= 16) {\n            return\n        }\n        setLastUpdate(s);\n\n        let updateLockups = async () => {\n            let lockups: LockupWithStatus[] = [];\n            for (let account of tokens.balances) {\n                let accLockups = await b.fetchTransferProposals(account.account)\n                lockups.push(...accLockups.map(v => {\n                    return {\n                        status: LockupStatus.AWAITING_VAA,\n                        ...v\n                    }\n                }))\n            }\n\n            let wormhole = WormholeFactory.connect(BRIDGE_ADDRESS, provider);\n            for (let lockup of lockups) {\n                if (lockup.vaaTime === undefined || lockup.vaaTime === 0) continue;\n\n                let signingData = lockup.vaa.slice(lockup.vaa[5] * 66 + 6)\n                for (let i = signingData.length; i > 0; i--) {\n                    if (signingData[i] == 0xff) {\n                        signingData = signingData.slice(0, i)\n                        break\n                    }\n                }\n                let hash = keccak256(signingData)\n                let submissionStatus = await wormhole.consumedVAAs(hash);\n\n                lockup.status = submissionStatus ? LockupStatus.COMPLETED : LockupStatus.UNCLAIMED_VAA;\n            }\n\n            setLockups(lockups);\n        }\n        updateLockups()\n    }, [s])\n\n    let executeVAA = async (v: LockupWithStatus) => {\n        let wh = WormholeFactory.connect(BRIDGE_ADDRESS, signer)\n        let vaa = new Buffer(v.vaa);\n        for (let i = vaa.length; i > 0; i--) {\n            if (vaa[i] == 0xff) {\n                vaa = vaa.slice(0, i)\n                break\n            }\n        }\n\n        let signatures = await b.fetchSignatureStatus(v.signatureAccount);\n        let sigData = Buffer.of(...signatures.reduce((previousValue, currentValue) => {\n            previousValue.push(currentValue.index)\n            previousValue.push(...currentValue.signature)\n\n            return previousValue\n        }, new Array<number>()))\n\n        vaa = Buffer.concat([vaa.slice(0, 5), Buffer.of(signatures.length), sigData, vaa.slice(6)])\n\n        message.loading({content: \"Signing transaction...\", key: \"eth_tx\", duration: 1000},)\n        let tx = await wh.submitVAA(vaa)\n        message.loading({content: \"Waiting for transaction to be mined...\", key: \"eth_tx\", duration: 1000})\n        await tx.wait(1)\n        message.success({content: \"Execution of VAA succeeded\", key: \"eth_tx\"})\n    }\n\n    let pokeProposal = async (proposalAddress: PublicKey) => {\n        message.loading({content: \"Poking lockup ...\", key: \"poke\"}, 1000)\n\n        let ix = await b.createPokeProposalInstruction(proposalAddress);\n        let recentHash = await c.getRecentBlockhash();\n        let tx = new Transaction();\n        tx.recentBlockhash = recentHash.blockhash\n        tx.add(ix)\n        tx.feePayer = wallet.publicKey;\n        let signed = await wallet.signTransaction(tx);\n        try {\n            await c.sendRawTransaction(signed.serialize())\n            message.success({content: \"Poke succeeded\", key: \"poke\"})\n        } catch (e) {\n            message.error({content: \"Poke failed\", key: \"poke\"})\n        }\n    }\n\n    let statusToPrompt = (v: LockupWithStatus) => {\n        switch (v.status) {\n            case LockupStatus.AWAITING_VAA:\n                return (<>Awaiting VAA (<a onClick={() => {\n                    pokeProposal(v.lockupAddress)\n                }}>poke</a>)</>);\n            case LockupStatus.UNCLAIMED_VAA:\n                return (<Button onClick={() => {\n                    executeVAA(v)\n                }}>Execute</Button>);\n            case LockupStatus.COMPLETED:\n                return (\"Completed\");\n        }\n    }\n\n    const columns = [\n        {\n            title: 'SourceAccount',\n            key: 'source',\n            render: (n: any, v: LockupWithStatus) => \"SOL: \" + v.sourceAddress.toString()\n        },\n        {\n            title: 'TargetAccount',\n            key: 'target',\n            render: (n: any, v: LockupWithStatus) => {\n                switch (v.toChain) {\n                    case 1:\n                        return \"SOL: \" + new PublicKey(v.targetAddress).toString()\n                    case 2:\n                        return \"ETH: 0x\" + new Buffer(v.targetAddress.slice(12)).toString(\"hex\")\n                }\n            }\n        },\n        {\n            title: 'Asset',\n            key: 'assetAddress',\n            render: (n: any, v: LockupWithStatus) => {\n                switch (v.assetChain) {\n                    case 1:\n                        return \"SOL: \" + new PublicKey(v.assetAddress).toString()\n                    case 2:\n                        return \"ETH: 0x\" + new Buffer(v.assetAddress.slice(12)).toString(\"hex\")\n                }\n            }\n        },\n        {\n            title: 'Amount',\n            key: 'amount',\n            render: (n: any, v: LockupWithStatus) => v.amount.div(new BN(10).pow(new BN(v.assetDecimals))).toString()\n        },\n        {\n            title: 'Status',\n            key: 'status',\n            render: (n: any, v: LockupWithStatus) => {\n                return (<>{statusToPrompt(v)}</>)\n            }\n        },\n    ];\n\n    return (<>\n            <h3>Pending transfers to Ethereum</h3>\n            <Table dataSource={lockups} columns={columns}/>\n        </>\n    )\n}\n\nexport default TransferProposals\n","/Users/david/Desktop/wormhole/web/src/utils/helpers.ts",[],{"ruleId":"131","replacedBy":"132"},{"ruleId":"133","replacedBy":"134"},{"ruleId":"135","severity":1,"message":"136","line":46,"column":42,"nodeType":"137","endLine":46,"endColumn":70},{"ruleId":"135","severity":1,"message":"136","line":48,"column":38,"nodeType":"137","endLine":53,"endColumn":31},{"ruleId":"138","severity":1,"message":"139","line":93,"column":6,"nodeType":"140","endLine":93,"endColumn":12,"suggestions":"141"},{"ruleId":"138","severity":1,"message":"142","line":68,"column":6,"nodeType":"140","endLine":68,"endColumn":15,"suggestions":"143"},{"ruleId":"144","severity":1,"message":"145","line":53,"column":16,"nodeType":"146","messageId":"147","endLine":53,"endColumn":29},{"ruleId":"144","severity":1,"message":"148","line":76,"column":7,"nodeType":"146","messageId":"147","endLine":76,"endColumn":20},{"ruleId":"149","severity":1,"message":"150","line":101,"column":14,"nodeType":"151","messageId":"152","endLine":101,"endColumn":16},{"ruleId":"149","severity":1,"message":"150","line":108,"column":21,"nodeType":"151","messageId":"152","endLine":108,"endColumn":23},{"ruleId":"149","severity":1,"message":"150","line":111,"column":21,"nodeType":"151","messageId":"152","endLine":111,"endColumn":23},{"ruleId":"149","severity":1,"message":"150","line":112,"column":32,"nodeType":"151","messageId":"152","endLine":112,"endColumn":34},{"ruleId":"149","severity":1,"message":"150","line":116,"column":21,"nodeType":"151","messageId":"152","endLine":116,"endColumn":23},{"ruleId":"149","severity":1,"message":"150","line":117,"column":32,"nodeType":"151","messageId":"152","endLine":117,"endColumn":34},{"ruleId":"149","severity":1,"message":"150","line":121,"column":21,"nodeType":"151","messageId":"152","endLine":121,"endColumn":23},{"ruleId":"149","severity":1,"message":"150","line":195,"column":21,"nodeType":"151","messageId":"152","endLine":195,"endColumn":23},{"ruleId":"149","severity":1,"message":"150","line":207,"column":28,"nodeType":"151","messageId":"152","endLine":207,"endColumn":30},{"ruleId":"149","severity":1,"message":"150","line":355,"column":22,"nodeType":"151","messageId":"152","endLine":355,"endColumn":24},{"ruleId":"149","severity":1,"message":"153","line":362,"column":33,"nodeType":"151","messageId":"152","endLine":362,"endColumn":35},{"ruleId":"149","severity":1,"message":"150","line":362,"column":46,"nodeType":"151","messageId":"152","endLine":362,"endColumn":48},{"ruleId":"149","severity":1,"message":"150","line":416,"column":19,"nodeType":"151","messageId":"152","endLine":416,"endColumn":21},{"ruleId":"138","severity":1,"message":"154","line":242,"column":6,"nodeType":"140","endLine":242,"endColumn":52,"suggestions":"155"},{"ruleId":"144","severity":1,"message":"156","line":3,"column":21,"nodeType":"146","messageId":"147","endLine":3,"endColumn":28},{"ruleId":"144","severity":1,"message":"157","line":91,"column":9,"nodeType":"146","messageId":"147","endLine":91,"endColumn":13},{"ruleId":"149","severity":1,"message":"150","line":109,"column":25,"nodeType":"151","messageId":"152","endLine":109,"endColumn":27},{"ruleId":"149","severity":1,"message":"150","line":110,"column":73,"nodeType":"151","messageId":"152","endLine":110,"endColumn":75},{"ruleId":"149","severity":1,"message":"153","line":123,"column":48,"nodeType":"151","messageId":"152","endLine":123,"endColumn":50},{"ruleId":"138","severity":1,"message":"158","line":179,"column":8,"nodeType":"140","endLine":179,"endColumn":34,"suggestions":"159"},{"ruleId":"149","severity":1,"message":"150","line":182,"column":23,"nodeType":"151","messageId":"152","endLine":182,"endColumn":25},{"ruleId":"149","severity":1,"message":"150","line":183,"column":48,"nodeType":"151","messageId":"152","endLine":183,"endColumn":50},{"ruleId":"149","severity":1,"message":"153","line":185,"column":41,"nodeType":"151","messageId":"152","endLine":185,"endColumn":43},{"ruleId":"138","severity":1,"message":"160","line":191,"column":8,"nodeType":"140","endLine":191,"endColumn":16,"suggestions":"161"},{"ruleId":"149","severity":1,"message":"150","line":199,"column":56,"nodeType":"151","messageId":"152","endLine":199,"endColumn":58},{"ruleId":"138","severity":1,"message":"162","line":203,"column":8,"nodeType":"140","endLine":203,"endColumn":95,"suggestions":"163"},{"ruleId":"149","severity":1,"message":"150","line":216,"column":56,"nodeType":"151","messageId":"152","endLine":216,"endColumn":58},{"ruleId":"149","severity":1,"message":"150","line":223,"column":38,"nodeType":"151","messageId":"152","endLine":223,"endColumn":40},{"ruleId":"149","severity":1,"message":"150","line":228,"column":38,"nodeType":"151","messageId":"152","endLine":228,"endColumn":40},{"ruleId":"149","severity":1,"message":"150","line":260,"column":58,"nodeType":"151","messageId":"152","endLine":260,"endColumn":60},{"ruleId":"149","severity":1,"message":"150","line":267,"column":36,"nodeType":"151","messageId":"152","endLine":267,"endColumn":38},{"ruleId":"149","severity":1,"message":"150","line":271,"column":36,"nodeType":"151","messageId":"152","endLine":271,"endColumn":38},{"ruleId":"149","severity":1,"message":"150","line":276,"column":66,"nodeType":"151","messageId":"152","endLine":276,"endColumn":68},{"ruleId":"138","severity":1,"message":"164","line":92,"column":6,"nodeType":"140","endLine":92,"endColumn":9,"suggestions":"165"},{"ruleId":"135","severity":1,"message":"136","line":160,"column":13,"nodeType":"137","endLine":164,"endColumn":14},"no-native-reassign",["166"],"no-negated-in-lhs",["167"],"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'b', 'c', 'lastUpdate', and 'wallet.publicKey'. Either include them or remove the dependency array.","ArrayExpression",["168"],"React Hook useEffect has a missing dependency: 'b.balances'. Either include it or remove the dependency array.",["169"],"@typescript-eslint/no-unused-vars","'approveAssets' is defined but never used.","Identifier","unusedVar","'tokenAccounts' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","React Hook useEffect has missing dependencies: 'coinInfo.assetAddress', 'coinInfo.chainID', 'coinInfo.decimals', and 'recipient'. Either include them or remove the dependency array.",["170"],"'Account' is defined but never used.","'slot' is assigned a value but never used.","React Hook useEffect has a missing dependency: 'updateBalance'. Either include it or remove the dependency array.",["171"],"React Hook useEffect has a missing dependency: 'coinInfo.balance'. Either include it or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setAmountValid' needs the current value of 'coinInfo.balance'.",["172"],"React Hook useEffect has a missing dependency: 'params'. Either include it or remove the dependency array.",["173"],"React Hook useEffect has missing dependencies: 'b', 'lastUpdate', and 'tokens.balances'. Either include them or remove the dependency array.",["174"],"no-global-assign","no-unsafe-negation",{"desc":"175","fix":"176"},{"desc":"177","fix":"178"},{"desc":"179","fix":"180"},{"desc":"181","fix":"182"},{"desc":"183","fix":"184"},{"desc":"185","fix":"186"},{"desc":"187","fix":"188"},"Update the dependencies array to be: [b, c, lastUpdate, slot, wallet.publicKey]",{"range":"189","text":"190"},"Update the dependencies array to be: [address, b.balances]",{"range":"191","text":"192"},"Update the dependencies array to be: [address, addressValid, tokenAccounts, bridge, coinInfo.chainID, coinInfo.assetAddress, coinInfo.decimals, recipient]",{"range":"193","text":"194"},"Update the dependencies array to be: [fromNetwork, fromAddress, updateBalance]",{"range":"195","text":"196"},"Update the dependencies array to be: [amount, coinInfo.balance]",{"range":"197","text":"198"},"Update the dependencies array to be: [fromNetwork, fromAddressValid, coinInfo, toNetwork, toAddress, toAddressValid, amount, params]",{"range":"199","text":"200"},"Update the dependencies array to be: [b, lastUpdate, s, tokens.balances]",{"range":"201","text":"202"},[2593,2599],"[b, c, lastUpdate, slot, wallet.publicKey]",[2006,2015],"[address, b.balances]",[6782,6828],"[address, addressValid, tokenAccounts, bridge, coinInfo.chainID, coinInfo.assetAddress, coinInfo.decimals, recipient]",[6523,6549],"[fromNetwork, fromAddress, updateBalance]",[6920,6928],"[amount, coinInfo.balance]",[7347,7434],"[fromNetwork, fromAddressValid, coinInfo, toNetwork, toAddress, toAddressValid, amount, params]",[2791,2794],"[b, lastUpdate, s, tokens.balances]"]